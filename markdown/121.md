# 121. 买卖股票的最佳时机(没做出来)DPDPDPDPDPDP

***股票问题的方法其实就是动态规划***因为它包含了重叠子问题，即买卖股票的最佳时机是由之前买或不买的状态决定的，而之前买或不买又由更早的状态决定的

根据题目描述其实就是找这个数组中,**前后数字的最大差值(正数)**,也就是题目中的利润.返回这个最大差值

## DP

遍历一遍数组,记录在我遍历的这一天之前的最小数组以及可以获得的最大利润

也就是官方题解2,其实是对DP的再次优化

```c++
int maxProfit(vector<int> &prices) {
  int min_price = 1000000;//首先因为是最低价格,所以要初始化一个大数
  int max_profit = 0; //因为是最低利润,并且当天买入卖出就是0,所以最大利润初始化为最小值0
  for (int num : prices) {
    max_profit = std::max(num - min_price, max_profit);
    min_price = std::min(num, min_price);
  }
  return max_profit;
}
```

--- 

# 什么是动态规划

动态规划（Dynamic Programming）是一种算法思想，它通常用于优化问题，例如寻找最短路径或最大价值的问题。

它的思想是将问题分解成许多子问题，并为每个子问题找到最优解。然后，通过合并这些子问题的最优解，可以获得原问题的最优解。

动态规划的核心思想是将问题分解成多个子问题，并使用记忆化技术来避免重复计算。

在解决问题时，我们首先解决所有子问题，将它们的解存储在一个表格中，并使用这些存储的解来解决原问题。

动态规划的一般步骤如下：

刻画一个最优解的结构特征；
递归地定义最优解的值；
计算最优解的值，通常采用自底向上的方式；
利用计算出的信息构造一个最优解。
动态规划算法通常包括以下几个步骤：

定义状态：将原问题转化成一个状态序列，每个状态表示问题的一个子集。
定义状态转移方程：将原问题的解表示为其子问题的解的函数，通过求解子问题的解，得到原问题的解。
初始化状态：定义问题的最小子问题的解，作为算法的起点。
确定计算顺序：将状态按照一定的顺序计算，保证计算某个状态所需要的所有子状态都已经被计算过。
最后，需要注意的是，动态规划并不是一种可以应用于所有问题的通用算法。在实际应用中，需要根据问题的性质和规模选择合适的算法。